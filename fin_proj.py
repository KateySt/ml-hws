# -*- coding: utf-8 -*-
"""fin-proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bfv9SXrlkNF11mAouuj1nanImeSEpZD7
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
import xgboost as xgb
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

def download_stock_data(ticker, start='2015-01-01', end='2024-01-01'):
    stock = yf.download(ticker, start=start, end=end)
    print("\n stock.head")
    print(stock.head())
    print("\n stock.tail")
    print(stock.info())
    print("\n stock.describe")
    print(stock.describe())
    return stock[['Close']]

def perform_eda(df):
    print("Summary Statistics:\n", df.describe())

    plt.figure(figsize=(12, 6))
    sns.histplot(df['Close'], bins=50, kde=True)
    plt.title('Distribution of Closing Prices')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(df['Close'], label='Close Price')
    plt.title('Stock Price Over Time')
    plt.legend()
    plt.show()

def prepare_data(df, time_steps=60):
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(time_steps, len(df_scaled)):
        X.append(df_scaled[i-time_steps:i, 0])
        y.append(df_scaled[i, 0])

    X, y = np.array(X), np.array(y)
    return X.reshape(X.shape[0], X.shape[1], 1), y, scaler

def build_lstm_model(input_shape):
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=input_shape),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
xgb_model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100)
linear_model = LinearRegression()
kmeans = KMeans(n_clusters=3, random_state=42)

if __name__ == "__main__":
    ticker = 'AAPL'
    stock_data = download_stock_data(ticker)

    perform_eda(stock_data)

    X, y, scaler = prepare_data(stock_data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    lstm_model = build_lstm_model((X_train.shape[1], 1))
    lstm_model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))

    lstm_predictions = lstm_model.predict(X_test)
    lstm_predictions = scaler.inverse_transform(lstm_predictions.reshape(-1, 1))
    y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    rf_model.fit(X_train_flat, y_train)
    xgb_model.fit(X_train_flat, y_train)
    linear_model.fit(X_train_flat, y_train)

    rf_predictions = rf_model.predict(X_test_flat).reshape(-1, 1)
    xgb_predictions = xgb_model.predict(X_test_flat).reshape(-1, 1)
    linear_predictions = linear_model.predict(X_test_flat).reshape(-1, 1)

    rf_predictions = scaler.inverse_transform(rf_predictions)
    xgb_predictions = scaler.inverse_transform(xgb_predictions)
    linear_predictions = scaler.inverse_transform(linear_predictions)

    clusters = kmeans.fit_predict(X_train_flat)

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_actual, label='Actual Price')
    plt.plot(lstm_predictions, label='LSTM Prediction')
    plt.plot(rf_predictions, label='Random Forest Prediction', linestyle='dashed')
    plt.plot(xgb_predictions, label='XGBoost Prediction', linestyle='dotted')
    plt.plot(linear_predictions, label='Linear Regression Prediction', linestyle='dashdot')
    plt.legend()
    plt.title(f'{ticker} Price Prediction Comparison')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.scatter(range(len(clusters)), clusters, c=clusters, cmap='viridis')
    plt.title('Cluster Assignments from K-Means')
    plt.xlabel('Data Points')
    plt.ylabel('Cluster')
    plt.show()


    plt.figure(figsize=(12, 6))
    plt.plot(lstm_predictions, label='LSTM Prediction', color='orange')
    plt.plot(xgb_predictions, label='XGBoost Prediction', color='cyan', linestyle='dotted')
    plt.legend()
    plt.title(f'LSTM vs XGBoost Predictions for {ticker}')
    plt.show()

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
import xgboost as xgb
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

def download_stock_data(ticker, start='2015-01-01', end='2024-01-01'):
    stock = yf.download(ticker, start=start, end=end)

    # Удаляем будущие данные и сортируем по дате
    stock = stock[['Close']].dropna().sort_index()

    print(stock.head())
    print(stock.tail())
    return stock

def perform_eda(df):
    print("Summary Statistics:\n", df.describe())

    plt.figure(figsize=(12, 6))
    sns.histplot(df['Close'], bins=50, kde=True)
    plt.title('Distribution of Closing Prices')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['Close'], label='Close Price')
    plt.title('Stock Price Over Time')
    plt.legend()
    plt.show()

def prepare_data(df, time_steps=60):
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(time_steps, len(df_scaled)):
        X.append(df_scaled[i-time_steps:i, 0])
        y.append(df_scaled[i, 0])

    X, y = np.array(X), np.array(y)
    return X.reshape(X.shape[0], X.shape[1], 1), y, scaler

def build_lstm_model(input_shape):
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=input_shape),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
xgb_model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100)
linear_model = LinearRegression()
kmeans = KMeans(n_clusters=3, random_state=42)

if __name__ == "__main__":
    ticker = 'AAPL'
    stock_data = download_stock_data(ticker)

    perform_eda(stock_data)

    X, y, scaler = prepare_data(stock_data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    lstm_model = build_lstm_model((X_train.shape[1], 1))
    lstm_model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))

    lstm_predictions = lstm_model.predict(X_test)
    lstm_predictions = scaler.inverse_transform(lstm_predictions.reshape(-1, 1))
    y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    rf_model.fit(X_train_flat, y_train)
    xgb_model.fit(X_train_flat, y_train)

    linear_model = LinearRegression()

    linear_model.fit(X_train_flat, y_train)

    rf_predictions = rf_model.predict(X_test_flat).reshape(-1, 1)
    xgb_predictions = xgb_model.predict(X_test_flat).reshape(-1, 1)
    linear_predictions = linear_model.predict(X_test_flat).reshape(-1, 1)

    rf_predictions = scaler.inverse_transform(rf_predictions)
    xgb_predictions = scaler.inverse_transform(xgb_predictions)
    linear_predictions = scaler.inverse_transform(linear_predictions)

    clusters = kmeans.fit_predict(X_train_flat)

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_actual, label='Actual Price')
    plt.plot(lstm_predictions, label='LSTM Prediction')
    plt.plot(rf_predictions, label='Random Forest Prediction', linestyle='dashed')
    plt.plot(xgb_predictions, label='XGBoost Prediction', linestyle='dotted')
    plt.plot(linear_predictions, label='Linear Regression Prediction', linestyle='dashdot')
    plt.legend()
    plt.title(f'{ticker} Price Prediction Comparison')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.scatter(range(len(clusters)), clusters, c=clusters, cmap='viridis')
    plt.title('Cluster Assignments from K-Means')
    plt.xlabel('Data Points')
    plt.ylabel('Cluster')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(lstm_predictions, label='LSTM Prediction', color='orange')
    plt.plot(xgb_predictions, label='XGBoost Prediction', color='cyan', linestyle='dotted')
    plt.legend()
    plt.title(f'LSTM vs XGBoost Predictions for {ticker}')
    plt.show()

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

def download_stock_data(ticker, start='2015-01-01', end='2024-01-01'):
    stock = yf.download(ticker, start=start, end=end)
    stock = stock[['Close']].sort_index()
    return stock

def perform_eda(df):
    plt.figure(figsize=(12, 6))
    sns.histplot(df['Close'], bins=50, kde=True)
    plt.title('Distribution of Closing Prices')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['Close'], label='Close Price')
    plt.title('Stock Price Over Time')
    plt.legend()
    plt.show()

def prepare_data(df, time_steps=60):
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(time_steps, len(df_scaled)):
        X.append(df_scaled[i-time_steps:i, 0])
        y.append(df_scaled[i, 0])

    return np.array(X).reshape(len(X), time_steps, 1), np.array(y), scaler

def build_lstm_model(input_shape):
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=input_shape),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25),
        Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

if __name__ == "__main__":
    ticker = 'AAPL'
    stock_data = download_stock_data(ticker)
    perform_eda(stock_data)

    X, y, scaler = prepare_data(stock_data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    lstm_model = build_lstm_model((X_train.shape[1], 1))
    lstm_model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))
    lstm_predictions = lstm_model.predict(X_test)
    lstm_predictions = scaler.inverse_transform(lstm_predictions.reshape(-1, 1))
    y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_actual, label='Actual Price')
    plt.plot(lstm_predictions, label='LSTM Prediction', color='orange')
    plt.legend()
    plt.title(f'{ticker} Stock Price Prediction using LSTM')
    plt.show()

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau

def download_stock_data(ticker, start='2015-01-01', end='2024-01-01'):
    stock = yf.download(ticker, start=start, end=end)
    stock['SMA_10'] = stock['Close'].rolling(window=10).mean()
    stock['SMA_50'] = stock['Close'].rolling(window=50).mean()
    stock['RSI'] = compute_rsi(stock['Close'])
    stock.dropna(inplace=True)
    return stock[['Close', 'Volume', 'SMA_10', 'SMA_50', 'RSI']]

def compute_rsi(data, window=14):
    delta = data.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def perform_eda(df):
    plt.figure(figsize=(12, 6))
    sns.histplot(df['Close'], bins=50, kde=True)
    plt.title('Distribution of Closing Prices')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['Close'], label='Close Price', color='blue')
    plt.plot(df.index, df['SMA_10'], label='10-day SMA', linestyle='dashed', color='red')
    plt.plot(df.index, df['SMA_50'], label='50-day SMA', linestyle='dashed', color='green')
    plt.title('Stock Price and Moving Averages')
    plt.legend()
    plt.show()

def prepare_data(df, time_steps=60):
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(time_steps, len(df_scaled)):
        X.append(df_scaled[i-time_steps:i])
        y.append(df_scaled[i, 0])

    return np.array(X), np.array(y), scaler

def build_lstm_model(input_shape):
    model = Sequential([
        Bidirectional(LSTM(100, return_sequences=True, input_shape=input_shape)),
        Dropout(0.2),
        LSTM(100, return_sequences=True),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25, activation='relu'),
        Dense(1)
    ])

    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

if __name__ == "__main__":
    ticker = 'AAPL'
    stock_data = download_stock_data(ticker)
    perform_eda(stock_data)

    X, y, scaler = prepare_data(stock_data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    lstm_model = build_lstm_model((X_train.shape[1], X_train.shape[2]))

    early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
    reduce_lr = ReduceLROnPlateau(monitor='val_loss', patience=5, factor=0.5)

    lstm_model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test),
                   callbacks=[early_stop, reduce_lr])

    lstm_predictions = lstm_model.predict(X_test)
    lstm_predictions = scaler.inverse_transform(np.hstack((lstm_predictions, np.zeros((lstm_predictions.shape[0], X.shape[2]-1)))))[:, 0]
    y_test_actual = scaler.inverse_transform(np.hstack((y_test.reshape(-1, 1), np.zeros((y_test.shape[0], X.shape[2]-1)))))[:, 0]

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_actual, label='Actual Price')
    plt.plot(lstm_predictions, label='LSTM Prediction', color='orange')
    plt.legend()
    plt.title(f'{ticker} Stock Price Prediction using Improved LSTM')
    plt.show()

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional, BatchNormalization
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau

# Функция для загрузки данных
def download_stock_data(ticker, start='2015-01-01', end='2024-01-01'):
    stock = yf.download(ticker, start=start, end=end)

    # Дополнительные индикаторы
    stock['SMA_10'] = stock['Close'].rolling(window=10).mean()
    stock['SMA_50'] = stock['Close'].rolling(window=50).mean()
    stock['RSI'] = compute_rsi(stock['Close'])
    stock['MACD'], stock['Signal_Line'] = compute_macd(stock['Close'])
    stock['ATR'] = compute_atr(stock)

    # Календарные признаки
    stock['DayOfWeek'] = stock.index.dayofweek
    stock['Month'] = stock.index.month

    stock.dropna(inplace=True)

    return stock[['Close', 'Volume', 'SMA_10', 'SMA_50', 'RSI', 'MACD', 'Signal_Line', 'ATR', 'DayOfWeek', 'Month']]

# RSI (индекс относительной силы)
def compute_rsi(data, window=14):
    delta = data.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# MACD (Moving Average Convergence Divergence)
def compute_macd(data, short_window=12, long_window=26, signal_window=9):
    short_ema = data.ewm(span=short_window, adjust=False).mean()
    long_ema = data.ewm(span=long_window, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    return macd, signal

# ATR (Average True Range)
def compute_atr(df, window=14):
    high_low = df['High'] - df['Low']
    high_close = np.abs(df['High'] - df['Close'].shift(1))
    low_close = np.abs(df['Low'] - df['Close'].shift(1))
    true_range = np.maximum(high_low, np.maximum(high_close, low_close))
    return true_range.rolling(window=window).mean()

# EDA
def perform_eda(df):
    plt.figure(figsize=(12, 6))
    sns.histplot(df['Close'], bins=50, kde=True)
    plt.title('Распределение цен закрытия')
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['Close'], label='Цена закрытия', color='blue')
    plt.plot(df.index, df['SMA_10'], label='10-дневная SMA', linestyle='dashed', color='red')
    plt.plot(df.index, df['SMA_50'], label='50-дневная SMA', linestyle='dashed', color='green')
    plt.title('Цена акции и скользящие средние')
    plt.legend()
    plt.show()

# Подготовка данных
def prepare_data(df, time_steps=60):
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(time_steps, len(df_scaled)):
        X.append(df_scaled[i-time_steps:i])
        y.append(df_scaled[i, 0])

    return np.array(X), np.array(y), scaler

# Улучшенная модель LSTM
def build_lstm_model(input_shape):
    model = Sequential([
        BatchNormalization(input_shape=input_shape),  # Нормализация данных
        Bidirectional(LSTM(100, return_sequences=True)),
        Dropout(0.2),
        LSTM(100, return_sequences=True),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25, activation='relu'),
        Dense(1)
    ])

    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

# Основной код
if __name__ == "__main__":
    ticker = 'AAPL'
    stock_data = download_stock_data(ticker)
    perform_eda(stock_data)

    X, y, scaler = prepare_data(stock_data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    lstm_model = build_lstm_model((X_train.shape[1], X_train.shape[2]))

    early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
    reduce_lr = ReduceLROnPlateau(monitor='val_loss', patience=5, factor=0.5)

    lstm_model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test),
                   callbacks=[early_stop, reduce_lr])

    lstm_predictions = lstm_model.predict(X_test)
    lstm_predictions = scaler.inverse_transform(np.hstack((lstm_predictions, np.zeros((lstm_predictions.shape[0], X.shape[2]-1)))))[:, 0]
    y_test_actual = scaler.inverse_transform(np.hstack((y_test.reshape(-1, 1), np.zeros((y_test.shape[0], X.shape[2]-1)))))[:, 0]

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_actual, label='Фактическая цена')
    plt.plot(lstm_predictions, label='Прогноз LSTM', color='orange')
    plt.legend()
    plt.title(f'{ticker} Прогноз цены акций с улучшенной LSTM')
    plt.show()











